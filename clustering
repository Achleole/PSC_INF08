from matplotlib import pyplot as plt
from scipy.cluster.hierarchy import dendrogram, linkage, fcluster
import numpy as np

def euclidiandistance(a=0,b=0):
    return abs(a-b)

#distance de substitution utilise pour les chaines de caracteres
def levensteindistance(ch1,ch2):
    m,n= len(ch1),len(ch2)
    import numpy as np
    d= np.zeros((m,n))
    for i in range(m):
        d[i,0]=i
    for j in range(n):
        d[0,j]=j

    for j in range(1,n):
        for i in range(1,m):
            if ch1[i]== ch2[j]:
                substitutioncost=0
            else:
                substitutioncost=1
            d[i,j]=min(d[i-1,j]+1, d[i,j-1]+1, d[i-1,j-1]+ substitutioncost)
    return (d[m-1,n-1]/max(m,n))

def levensteindistancecouple(a,b):
    (ch,i,j)=a
    (chh,ii,jj)=b
    return levensteindistance(ch,chh)


#etant donne une liste d'elements evaluables par la distance donnee, calculer la partie inferieure de la matrice de distance rangee dans un vecteur
def distancematrix(list,distance=levensteindistance):
    n = len(list)
    ll = np.zeros(((n*n-n)//2))
    s=0
    for i in range(0,n):
        for j in range(0,n):
            if i<j:
                ll[s]=distance(list[i],list[j])
                s+=1
    return ll


#n'est pas utilise dans le programme
#etant donnee une liste d'elements evaluables par la distance donnee, calculer la matrice
# dont la position i,j represente la distance entre le i et j-iemes elements de la liste
def pleindistancematrix(list,distance=levensteindistance):
    n = len(list)
    ll = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            ll[i,j] = distance(list[i],list[j])
    return ll

#tracer un dendrogramme
def tracerdendrogram(list,dist=levensteindistance):
    X = distancematrix(list,dist)
    Z = linkage(X,'ward',optimal_ordering=True)
    fig = plt.figure(figsize=(25,10))
    dn = dendrogram(Z)
    plt.show()

def clustering(list,epsilon=0.01):
    X = distancematrix(list)
    Z = linkage(X, 'average')
    clus = fcluster(Z,epsilon)
    l=[]
    maxclus = max(clus)
    for i in range(1,maxclus+1):
        listaajouter = [j for j in range(len(clus)) if clus[j]==i]
        l.append(listaajouter)
    print(l)
    return l



def test():
    mots= ["absent","absente","absents","indenpendants","indenpendant","endependant","independante"]
    clustering(mots,0.01)
    #print(pleindistancematrix(mots,levensteindistance))
    #print(distancematrix(mots,levensteindistance))
    X = distancematrix(mots)
    Z = linkage(X,'average')
    resultat = fcluster(Z,0.01)
    print(resultat)
    print(Z)
    fig = plt.figure(figsize=(25, 10))
    dn = dendrogram(Z)
    plt.show()

test()



def dictionnairetolist(dict):
    l=[]
    for cpuid in dict:
        for instructionid in dict[cpuid]:
            l.append((dict[cpuid][instructionid],cpuid,instructionid))
    return l

#Given a dictionary of dictionary, return sth with same structure but contents are replaced by the number of cluster to which belongs the original instruction
def clusteringdict(dict):
    clustering(dictionnairetolist(dict))


#l = [1,10,100,1000]
#print(pleindistancematrix(l,euclidiandistance))
#print(distancematrix(l,euclidiandistance))
